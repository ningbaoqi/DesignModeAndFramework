### 单一职责原则
+ 单一职责原则（Single Responsibility Principle简称为SRP）：应该有且仅有一个原因引起类的变更；对于单一职责原则，建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起改变；只要做过项目，肯定要接触到用户、机构、角色管理这些模块，基本上使用的都是RBAC模型（Role-Based Access Control基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）和资源的行为（权限）分离，确实是一个很好的解决办法；
#### 项目说明
+ 需要用户管理，修改用户的信息，增加机构（一个人属于多个机构），增加角色等，用户有这么多的信息和行为要维护，设计出合理的架构；
##### 错误的例子
+ 把这些写到一个接口中，都是用户管理类中的元素；

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-1.jpg)

##### 错误的分析
+ 因为用户的属性和用户的行为没有分开，这是一个严重的错误，这个接口确实设计的一团糟，应该把用户的信息抽取成一个BO（Business Objecrt，业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑）；
##### 按照分析的改进
+ 重新拆封成两个接口，IUserBO负责用户的属性，也就是IUserBO的职责就是收集和反馈用户的属性信息，IUserBiz负责用户的行为，完成用户信息的维护和变更；

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-2.jpg)

+ 这样在使用时要获得用户信息，就当是IUserBO实现类，要是希望维护用户的信息，就把它当作IUserBiz的实现类；如下面代码使用：

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-3.jpg)

##### 最终的设计
+ 在实际的使用中，我们更倾向于使用两个不同的类或接口，一个是IUserBO，一个是IUserBiz；使用单一原则思想；

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-4.jpg)

### 绝杀技，打破你的传统思维
#### 项目说明
+ 电话通话的时候有4个过程发生：拨号、通话、回应、挂机，设计出合理的架构；
##### 一般的设计

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-5.jpg)

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-6.jpg)

##### 更好优化的分析
+ 单一职责原则要求一个接口或类只有一个原因引发变化，也就是一个接口或类只有一个职责，它就负责一件事情；但是该例子是吗？好像不是！IPhone这个接口可不是只有一个职责，它包含了两个职责：一个是协议管理，一个是数据传送。dial()和hangup()两个方法实现的是协议管理，分别负责拨号接通和挂机；chat()实现的是数据的传送，把我们的话转换成模拟信号或数字信号传递到对方，然后再把对方传递过来的信号还原成我们所能听得懂的语言。发现上面类图的IPhone接口包含了两个职责，而且这两个职责的变化不互相影响，那就需要考虑分成两个接口；

##### 按照分析的改进

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-7.jpg)

##### 再次分析
+ 这个架构确实是符合了单一职责原则，但是一个手机类要把ConnectionManager和DataTransfer组合在一块才能使用，组合是一种强耦合关系，你和我都有共同的生命周期，这样的强耦合关系还不如使用接口实现的方式呢，而且该增加了类的复杂性，多个两个类；

##### 最终的设计

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-8.jpg)

+ 这样一个类实现了两个接口，把两个职责融合在一个类中，可能你会觉得这个Phone有两个原因引起变化，是的，但是别忘记了我们是面向接口编程，我们对外公布的是接口而不是实现类，而且，如果真要实现类的单一职责，这个就必须使用上面的组合模式了，这会引起类间耦合过重、类的数量增加等问题，认为增加了设计的复杂性；


#### 单一职责原则的好处

|单一职责原则的好处|
|------|
|类的复杂性降低，实现什么职责都有明确清晰的定义|
|可读性提高了，复杂性降低了，那当然可读性提高了|
|可维护性提高了，可读性提高了，当然更容易维护了|
|变更引起的风险降低了，变更是必不可少的，如果接口的单一职责原则做的好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护行都有非常大的帮助|


#### 总结
+ 单一职责原则最难划分的就是职责，一个职责一个接口，但问题是“职责”没有一个量化的标准，一个类到底要负责哪些职责？这些职责该怎么细化？细化后是否都要有一个接口或类？这些都需要从实际的项目去考虑，从功能上来说，定义一个IPhone接口也没有错，实现了电话的功能，而且设计还很简单，仅仅一个接口，一个实现类，实际的项目几乎大家都会这么设计，项目要考虑可变因素和不可变因素，以及相关的收益成本比率，因此设计一个IPhone接口也可能是没有错的，但是，如果纯从“学究”理论上分析就有问题了，有两个可以变化的原因放到了一个接口中，这就为以后的变化带来了风险；如果以后模拟电话升级到数字电话，会不会对整个系统影响很大；单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计的是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异；

#### 我单纯，所以我快乐
+ 对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了，生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会认为增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性，所以原则是死的，人是活的，这句话很有道理；单一职责适用于接口、类、同时也适用于方法，一个方法尽可能做一件事，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息中”，这个方法的颗粒太大，会让人产生模糊的想法，因为不明确具体修改的是哪个具体的项，如：

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-9.jpg)

+ 比较好的设计如下：

![image](https://github.com/ningbaoqi/DesignModeAndFramework/blob/master/gif/pic-10.jpg)
